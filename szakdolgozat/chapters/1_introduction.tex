\Chapter{Bevezetés}

A mai világban nehezen elképzelhetőnek tűnnek azok a számítógépek, amik egyszerre csak egyetlen folyamatot képesek futtatni.
A definiciója a single-tasking rendszereknek, kicsit értelmét vesztette a modern hardware-eken. Egy multi tasking rendszer már alapvető követelménynek tekinthető manapság az általános célú operációs rendszerek között. Egy ilyen rendszerben, több proccess verseng egymással és mindenki szeretne processzor időhöz jutni. Könnyen előfordulhat, hogy száz, akár kétszáz processz is várakozik, de nekünk nincs kétszáz processzorunk, hogy mindenki futni tudjon. Ezt egy "pszeudo párhuzamossággal" éri el a rendszer, ami azt jelenti, hogy váltogatva futnak és ez a váltogatás nagyon gyorsan történik. Egy másodperc alatt akár ezerszer is bekövetkezhet.
A kernel egyik fő feladata a CPU kiosztása, egy processz számára. El kell döntenie, hogy melyik futásra kész állapotú processz kapja meg a CPU-t.
Processz ütemezőnek hívják, a kernelnek azt a részét, ami ennek az eldöntéssel foglalkozik.
%https://users.iit.uni-miskolc.hu/~vinczed/ldapauth/osbsc2019/Operacios-rendszerek-jegyzet.pdf
%https://www.cs.rutgers.edu/~pxk/416/notes/07-scheduling.html

Négy olyan esemény fordulhat elő, ahol az ütemezőnek lépnie kell és döntést kell hoznia:
\begin{itemize}
  \item Az aktuális processz futó állapotból, blokkolt állapotba kerül, ez I/O kérés vagy gyerek processzre való várakozás miatt következhet be.
  \item Egy I/O művelet befejeződésének hatására, egy blokkolt processz, futásra kész állapotra vált. Ekkor az ütemező eldönti, hogy az aktuálisan futó processzt preemptálja és megválassza az új kész állapotú processzt.
  \item Egy processz terminálódásakor.
  \item Óraeszköztől származó megszakítás hatására, a processz futó állapotból, futásra kész állapotra vált. 
\end{itemize}

A dolgozat azt vizsgálja, hogy a Linux kernel esetében milyen lehetőségek vannak az ütemezés optimalizálására, különféle operációs rendszer felhasználási módok esetén. Tipikusan elkülöníthetjük például az asztali környezeteket, illetve a szerverként üzemeltetett rendszereket. A dolgozat áttekinti az ismert ütemezési algoritmusokat, ezután pedig a Completely Fair Scheduler optimalizálásra keres megoldásokat. Benchmark programok segítségével figyelem meg, hogy az ütemezőn végzett változtatások milyen hatást gyakorolnak a teszt eredmények értékeire.
Az így kapott adatok alapján, egy Machine learning program segítségével készítek javaslatokat, az ütemezőhöz tartozó kernel változók módosítására. A felhasználónak ki kell választania néhány felhasználási módot, ami alapján a program megpróbálja a lehető legjobb paraméterkészletet visszaadni, az ütemező megfelelő hangolására.